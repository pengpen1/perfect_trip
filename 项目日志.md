# perfect*trip*项目日志

## 接口文档

1.获取所有城市
http://123.207.32.32:1888/api/city/all



## 引言

别管样式多复杂、有没有网络请求、结构优不优雅，先能看到大概样式在说，**记住完成项目为首要任务！**



## 一、2022-7-27

### 1.动态加载 img 的 src 属性问题

动态的设置（变量）url 的值，内部不会去解析成正确路径的

```js
 //<img :src="data.img" alt="首页" />
 <img :src="@/assets/img/tabbar/tab_favor.png" alt="首页" />
 //在webpack环境下可以用require()包裹
 //vite环境下
```

解决办法：

```js
<img :src="getAssetURl(data.image)" :alt="data.text" />
function getAssetURl(imagurl) {
  //  import.meta.url当前文件的地址，基于当前文件地址生成url
  return new URL(`../../assets/img/${imagurl}`, import.meta.url).href;
}
```

## 二、2022-7-28

### 1.npm i vue --force 引发的问题

因为 element-plus 依赖的是 vue 的 3.1 的一个版本，强制安装最新版，会导致不能安装，解决办法是可以用 yarn 安装或者重新 npm i --force

### 2.隐藏关 tabbar

方法 1：在 city 路由对象里增加 meta 属性，并定义 hideTabbar 为 true
然后在 App 组件里：利用 useRoute()可以拿到当前展示的路由对象，而且是响应式的！
最后加个 v-if='!currentRoute.meta.hideTabbar'

//useRoute()等价于在 template 中使用$route

方法 2：tabbar 是用 fixed 定位的，我们让 city 盒子的 z-index 设置大些，覆盖 tabbar 即可；

```css
/* 需要隐藏tabbar的页面 */
.top-page {
  position: relative;
  z-index: 9;
  height: 100vh;
  background-color: rgb(255, 255, 255);
  overflow-y: auto;
}
```

直接抽成一个公共类，需要隐藏 tabbar 的组件使用一下类即可

## 三、2022-7-29

### 1.分层架构思想

每个层级做对应的任务，方便管理和维护，且组件中的代码逻辑不会过多，其他组件页更好使用 state

### 2.固定 top 区域的两种方法

1.top 区域标准流，content 区域自身滚动

```css
.content {
  height: calc(100vh - 98px);
  overflow-y: auto;
}
```

2.top 区域 fixed 定位
缺点的滚动条不好看

![1659068569980](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659068569980.png)

### 3.响应式疑问

根据选中的标签获取 city 数据

```js
const currentGroup = allCities.value[tabActiveName.value];
```

这里都是通过.value 直接拿到的数据，所以不是响应式的

这里都是通过.value 直接拿到的数据，所以不是响应式的

解决办法，用 computed 即可 computed(() => allCities.value[tabActiveName.value])
它会自动收集依赖，如 allCities，当依赖改变时，会重新计算出属性值，从而形成响应式

在 template 中和 computed 中的逻辑类似，当依赖 allCities、tabActiveName 发生改变时就会重新渲染组件。

![1659084187615](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659084187615.png)

疑惑瞬间少了不少,这就是数据处理呀

## 四、2022-7-30

### 1.优化城市列表渲染速度

原来是依靠 v-model:active="tabActiveName"的切换来实现传入 CityGroup 的 props 改变，
从而实现两种城市列表的切换。那么每次切换都会重新渲染，有点不合适。

```vue
<CityGroup :currentGroup="currentGroup"></CityGroup>
```

优化方案 1：虚拟列表

优化方案 2：v-show

```vue
<!-- allCities是两个group对象 -->
<template v-for="(value, key, index) in allCities" :key="index">
  <CityGroup :current-group="value" v-show="key === tabActiveName"></CityGroup>
</template>
```

### 2.自定义组件绑定事件的疑惑

![1659163897379](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659163897379.png)

首先排除 props，那么$attrs是什么意思？有无跟组件对绑定事件的影响?
$attrs 现在包含了所有传递给组件的 attribute，包括 class 和 style;
包含了父作用域中不作为组件 props 或自定义事件的 attribute 绑定和事件。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 v-bind="$attrs" 传入内部组件——这在创建高阶的组件时会非常有用。

Attribute 继承
当组件返回单个根节点时，非 prop 的 attribute 将自动添加到根节点的 attribute 中!

通过将 inheritAttrs 选项设置为 false，你可以使用组件的 $attrs property 将 attribute 应用到其它元素上，该 property 包括组件 props 和 emits property 中未包含的所有属性 (例如，class、style、v-on 监听器等)。可以使用 v-bind 缩写来完成。

与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute fallthrough (隐式贯穿) 行为。如果未显式绑定 $attrs，将发出运行时警告。

```html
<custom-layout id="custom-layout" @click="changeValue"></custom-layout>
```

```js
// 这将发出警告
app.component("custom-layout", {
  template: `
<header>...</header>
<main>...</main>
<footer>...</footer>
`,
});

// 没有警告，$attrs 被传递到<main> 元素
app.component("custom-layout", {
  template: `
    <header>...</header>
    <main v-bind="$attrs">...</main>
<footer>...</footer>
`,
});
```

我实验了的，多个跟组件确实会报错，但是我 v-bind="$attrs"绑定到一个 H2 元素后，
点击其他的 H2 也会触发事件。

我知道了，移动端触摸范围是圆型，所以实际上只能点击绑定了的元素才可以触发事件。



### 3.日期处理\_获取明天的日期

![1659171270221](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659171270221.png)

利用了 dayjs 库，方法一：传入今天的时间戳，加上对应的秒数(10 位)或毫秒数(13 位)

方法二：

```js
const newDate = new Date();
const currentDate = formatMonthDate(newDate);
// 如果 +1 超出了月份的合理范围，setDate 将会相应地更新 Date 对象。
const endDate = formatMonthDate(newDate.setDate(newDate.getDate() + 1));
```



### 4.网络请求位置探究

热门城市的网络请求我自己是在子组件中请求的，这样不利于管理，还是在父组件中统一
请求在传递给子组件吧

![1659414760344](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659414760344.png)



## 五、2022-7-31

### 1.动态组件和异步组件

我感觉都忘完了哟。

### 2.行高？

行高减去文字高度，然后平分剩下的空间，如果剩下的是小数，如 1.8，
有些浏览器就会一边分配 1，另一边 0.8，0.8 是小数，有些浏览器直接会向下取整。
这就导致看起来，不对称。
放大之后，可能会对称，因为浏览器会先将文字高度放大，在去计算有没有小数，需要向下取整不。

### 3.路由传参 params 和 query 的区别

一个是动态路由，一个是查询参数，就算?key = value &

```js
// 传
router.push({
    path: "/search",
    query: {
      startDate: currentDate.value,
      endDate: endDate.value,
      // currentCity: cityStore.currentCity.cityName,相当于在store中取
      currentCity: currentCity.value.cityName,
    },
  });

  // 接收
    <h2>开始:{{ $route.query.startDate }}</h2>
    <h2>结束:{{ $route.query.endDate }}</h2>
    <h2>城市:{{ $route.query.currentCity }}</h2>
```

还是方便，忘没忘记 react 中路由传参的三种方式呢？

### 4.隐藏滚动条

```less
.categories {
  display: flex;
  &::-webkit-scrollbar {
    display: none;
  }
```

-webkit-scrollbar 是一个伪元素和 after 一样，所以用 less 的话需要再前面加&
且这个方法移动端，pc 端都可以用，因为大多浏览器都用的 webkit 内核

### 5.加载长列表数据

**5.1 一点一点实现，先实现点击按钮加载更多的数据**

```js
let page = 1;
homeStore.fetchHouseList(page++);
const getMoreData = () => {
  homeStore.fetchHouseList(page++);
};
```

这里的 page 交给 home 管理也可以，但最好给 homeStore 统一管理
page 就表示下一次请求分页数据要在服务器中请求第几页。
展示的话先展示展示文本：

```vue
<template v-for="(item, index) in houseList" :key="index">
  <p>{{ item.data.houseName }}</p>
</template>
```

**5.2 根据 discoveryContentType:9||3** **的类型展示不同的组件**

```html
<div class="house-item-v9">
  <div class="inner-item">
    <div class="cover">
      <img :src="type9_Data.image.url" alt="" />
    </div>

    <div class="info">
      <div class="summary">{{ type9_Data.summaryText }}</div>
      <div class="houseName">{{ type9_Data.houseName }}</div>
      <div class="rate-price">
        <van-rate
          size="12"
          gutter="0"
          color="#fff"
          :model-value="Number(type9_Data.commentScore)"
        />
        <span class="finalPrice"> {{ "￥" + type9_Data.finalPrice }}</span>
      </div>
    </div>
  </div>
</div>
```

这里拆解了 v-model，就只传值 5 过去，不双向绑定

**5.3 监听页面滚动，自动加载更多**
首先明白页面滚动是由 window 窗口造成的还是元素自身 overflow-y 造成的？

我们首页的滚动是由窗口造成的，scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数(已经滚动的距离)，scrollHeight 元素内容高度的度量，包括由于溢出导致的视图中不可见内容。

**网页可见区域高：document.body.clientHeight**
**网页正文全文高：document.body.scrollHeight**
**网页可见区域高（包括边线的高）：document.body.offsetHeight**
**网页被卷去的高：document.body.scrollTop**
**屏幕分辨率高：window.screen.heigh**

![1659315480053](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659315480053.png)

`scrollTop`是一个非整数，而`scrollHeight`和`clientHeight`是四舍五入的，因此确定滚动区域是否滚动到底的唯一方法是查看滚动量是否足够接近某个阈值 (在本例中为`1`)：

```js
Math.abs(element.scrollHeight - element.clientHeight - element.scrollTop) < 1;
```

**5.4 监听窗口，自动请求**

```js
window.addEventListener("scroll", () => {
  const scrollHeight = document.documentElement.scrollHeight;
  const clientHeight = document.documentElement.clientHeight;
  const scrollTop = document.documentElement.scrollTop;
  if (scrollHeight - clientHeight - scrollTop < 1) {
    homeStore.fetchHouseList();
  }
});
```

**5.5 那么，问题来了**

![1659318472866](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659318472866.png)

如果切换了页面，对窗口的监听可还是**存在**的，这个一定要小心！

来吧，优化代码结构

开始监听可以放到生命周期—onMounted 里

移除监听放到生命周期—onUnmounted 里

监听函数可以抽取到 hooks 里，提高复用性

**这里还不够严谨，如果用了 keep-alive 缓存组件呢？**

有时想保存组件的状态，以避免反复渲染导致的性能问题。

在 keep-alive 缓存的组件激活时调用 onActivated 里—开始监听

在 keep-alive 缓存的组件失活时调用 onDeactivated 里—移除监听

**最终 hook 代码展示**

```js
export function useListenerScroll(successCallback) {
  const scrollListenerHandler = () => {
    const scrollHeight = document.documentElement.scrollHeight;
    const clientHeight = document.documentElement.clientHeight;
    const scrollTop = document.documentElement.scrollTop;
    if (scrollHeight - clientHeight - scrollTop < 1) {
      successCallback();
    }
  };
  onMounted(() => {
    window.addEventListener("scroll", scrollListenerHandler);
  });
  onUnmounted(() => {
    window.removeEventListener("scroll", scrollListenerHandler);
  });
}

//使用
useListenerScroll(() => {
  homeStore.fetchHouseList();
});
```

**5.6 嘿嘿嘿，loading 可以不用但不能没有**

loading组件是好实现，也设置了一个变量isLoading放入了mainStore里，但是那么多的网络请求如何监听呢？

你有没有想到呢？



没错，就是在我们封装类PQRequest里实现，**所有的网络请求都会经过request方法**



那直接在调用request方法时将isLoading改为true，有结果后改为false

![1659422659153](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659422659153.png)

but，这样不够优雅，这和业务代码混到了一起，我们可以将loading的展示与否**放到每个实例独有的拦截器**里面：

![1659426793922](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659426793922.png)





**5.7 抽取 hook 方案 2**

![1659338117845](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659338117845.png)

直接给调用 hook 的组件返回一个 ref，让组件自己决定做哪些操作，这个优化是真的 6666，vue2 要这么做的话，估计的用 mixin 混入对应的 options。

```js
//使用
const { isReachBottom } = useListenerScroll();
watch(isReachBottom, (newValue) => {
  if (newValue) {
    // 发送网络请求，并将数据存储在store后将ref值改为false
    homeStore.fetchHouseList().then(() => {
      isReachBottom.value = false;
    });
  }
});
```

### 6.报错的提示

妈蛋，下次遇到这种报错，检查检查 import 导入路径有没有写错！
GET http://localhost:5173/src/components/HouseItemV9%20l/HouseItemV9.vue net::ERR_ABORTED 404 (Not Found)

### 7. 两行且隐藏后面的内容

```css
.name {
  margin: 5px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

/* 单行隐藏 */
.houseName {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin: 10px 5px 0 5px;
}
```

它只有在 display 属性设置成 -webkit-box 或者 -webkit-inline-box 并且 -webkit-box-orient (en-US) 属性设置成 vertical 时才有效果

在大部分情况下，也需要设置 overflow 属性为 hidden, 否则，里面的内容不会被裁减，并且在内容显示为指定行数后还会显示省略号 (ellipsis ).

在 webkit 应用程序中，-webkit-box-orient 指定盒子是水平还是垂直布局其内容。

### 8.处理售价标签

![1659272481030](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659272481030.png)

```css
.new {
  color: #ff9645;
  font-size: 14px;
}

.old {
  margin: 0 3px;
  color: #999;
  font-size: 12px;
  text-decoration: line-through;
}

.tip {
  background-image: linear-gradient(270deg, #f66, #ff9f9f);
  color: #fff;
  padding: 2px 6px;
  border-radius: 8px;
  line-height: 1;
}
```

利用在对称轴上 start 方向的对齐方式，做到这样的效果，妙啊。

## 六、 2022-8-1

### 1.对于 ref 和 watch 的使用

1.

```js
//这是我自己写的，但不是响应式的，依赖都没收集到
const { isReachBottom } = useListenerScroll();
if (isReachBottom.value) {
  homeStore.fetchHouseList().then(() => {
    isReachBottom.value = true;
  });
}

//正确写法
watch(isReachBottom, (newValue) => {
  if (newValue) {
    // 发送网络请求，并将数据存储在store后将ref值改为false
    homeStore.fetchHouseList().then(() => {
      isReachBottom.value = false;
    });
  }
});
```

2.

```js
//这是我自己写的，会不会执行依赖太频繁，用计算属性改进下
<div v-if="scrollTop > 100">我是 search</div>;

// 更改了一下
const isShowSearch = computed(() => {
  return scrollTop.value >= 100;
});
```

我用 onUpdated 测试了一下，并没有优化哎！（onUpdated 数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用）。
这里一个是 ref 变化后执行 js 逻辑，一个是变化后修改另一个变量的值，所以对 computed 和 watch 要好好理解呀。

### 2.useListenerScroll 还能升级

我去，完全想不到，但是这样使用 hook，对我使用 react 帮助很大。
优化——可拓展性
优化——节流——underscore {npm i underscore}

```js
export function useListenerScroll() {
  // hook_v2 调用hook返回多个个ref，高扩展性高复用性
  // 1.定义需要返回的ref变量
  const isReachBottom = ref(false);
  const scrollHeight = ref(0);
  const clientHeight = ref(0);
  const scrollTop = ref(0);

  // 2.定义监听窗口滚动的回调函数
  const scrollListenerHandler = throttle(() => {
    scrollHeight.value = document.documentElement.scrollHeight;
    clientHeight.value = document.documentElement.clientHeight;
    scrollTop.value = document.documentElement.scrollTop;
    if (scrollHeight.value - clientHeight.value - scrollTop.value < 1) {
      console.log("滚动到底了嗷");
      isReachBottom.value = true;
    }
  }, 150);

  // 3.在调用此hook的组件的生命周期里监听或取消scroll事件
  onMounted(() => {
    window.addEventListener("scroll", scrollListenerHandler);
  });
  onUnmounted(() => {
    window.removeEventListener("scroll", scrollListenerHandler);
  });
  onActivated(() => {
    window.addEventListener("scroll", scrollListenerHandler);
  });
  onDeactivated(() => {
    window.removeEventListener("scroll", scrollListenerHandler);
  });

  // 4.返回ref变量
  return { isReachBottom, scrollHeight, scrollTop, clientHeight };
}
```

### 3.路径和导航按钮不匹配问题

这是遗留好久的 bug 了，在做后台管理系统时就有这个问题，从 url 直接输入某个页面的路径后，导航按钮并不会对应的出现高亮。

来看看，先前我们如何做 active 样式的：

高亮是通过.router-link-active 实现的，这个是没有 bug：

```css
.router-link-active .tabbar_text {
  color: var(--primary-color);
}
```

active 图片是通过监听点击，传入当前页面对应的索引，v-if 当前索引比对自身索引来实现的：

```vue
<div class="tabbar_wrap">
      <template v-for="(data, index) in tabbarData" :key="data.id">
        <router-link :to="data.path" @click="handleClikLink(index)">
          <img
            :src="getAssetURl(data.image)"
            :alt="data.text"
            v-if="$route.meta.currentIndex !== index"
          />
          <img :src="getAssetURl(data.imageActive)" :alt="data.text" v-else />
          <span class="tabbar_text">{{ data.text }}</span>
        </router-link>
      </template>
    </div>
```

```js
//set up
const currentIndex = ref(0);
const handleClikLink = (index) => {
  currentIndex.value = index;
};
```

**问题的根源：**是因为当前索引默认是 0 的，而切换当前索引需要点击对应的 router-link，但是我们直接通过 path 切换是不会触发点击事件的，这就导致页面切换了，但是按钮没变的尴尬事件。

**解决方法：**

方案 1：给路由对象添加 meta 属性，用于保存当前索引，组件中用 v-if 比对 当前路由对象中保存的当前索引和自身索引，从而实现 active 样式。

```js
  //这里只演示了一个route
   {
      path: "/home",
      component: () => import("../views/home/Home.vue"),
      meta: {
        currentIndex: 0,
      },
    },
```

```js
//需要切换的元素或组件中加入v-if
v-if="$route.meta.currentIndex !== index"
```

如果不喜欢在 template 中写这么长的的表达式，页可以在组合式 api 也就是 setup 中调用 useRoute()，返回当前路由对象。相当于在模板中使用 `$route`。然后再用个 computed 或者 watch 都行。

方案 2：用 watch 的话就可以监听改变，然后改 ref 的值。这里监不听监听都可以。

```js
const currentIndex = ref(0);
const handleClikLink = (index) => {
  currentIndex.value = index;
};
const route = useRoute();
watch(route, (newValue) => {
  currentIndex.value = newValue.meta.currentIndex;
});
```

方案 3：用 computed 的话就返回一个不可变的响应式 ref 对象，根据这个 ref 的值再去比较自身索引即可。

```js
const route = useRoute();
const currentIndex = computed(() => {
  return route.meta.currentIndex;
});
```

当然我还是喜欢直接在 template 中用$route，简单粗暴。

方案 4：如果用的 ui 库，它一般都会让你用 v-model 绑定一个 ref，用于决定当前 active 元素，此时要修改 bug 还是得围绕如何修改 ref 来，下面是一个例子：

![1659360171756](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659360171756.png)

tabbarData 是放每个导航按钮对应信息的数组，当找不到对应的 path 时 index 为-1，直接 return

### 4.scoped 样式穿透问题

1.当父组件里的 class 中有和子组件的根元素上的 class 一样的时，可以在父组件里用那个 class 控制子组件根元素的样式。

```vue
<div class="lala"></div>
<Demo></Demo>
```

```css
.lala {
  background: #000;
}
```

```vue
<template>
  <div class="lala">lLl</div>
</template>

<script setup></script>

<style lang="less" scoped>
div {
  width: 20px;
  height: 10px;
  background: rgb(209, 148, 148);
}
</style>
```

![1659365460863](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659365460863.png)

结果就算父组件上的用 class 定义的样式修改了子组件上的样式。

2.直接在子组件上定义 class，可以操控子组件根元素的样式

```vue
<div v-if="isShowSearch" class="search-bar-wrap">
      <SearchBar class="lala" />
</div>
```

```css
.lala {
  background-color: rgb(154, 105, 105);
}
```

3.如果是子组件上有很多根元素，那么会报错：

**无关的非道具属性（类）已传递给组件，但无法自动继承，因为组件呈现片段或文本根节点。**

**4.原理**

```html
<div class="lala" data-v-4197bd12="" data-v-4533200f="">lLl</div>
```

scoped 三条渲染规则：

- 给 HTML 的 DOM 节点加一个不重复 data 属性(形如：data-v-123)来表示他的唯一性
- 在每句 css 选择器的末尾（编译后的生成的 css 语句）加一个当前组件的 data 属性选择器（如[data-v-123]）来私有化样式
- 如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性

## 七、 2022-8-2

### 1.元素宽度问题

我还在想为什么我设置了 padding，SearchBar 的样式还是不对，一看原来是我设置了

```js
// width: 100%;
```

其实不用的，设置了下面这个，应该就相当于 100%l 吧

```css
 {
  position: fixed;
  top: 0;
  right: 0;
  left: 0;
}
```

还是用实验说明吧：

```css
 <style>
      .content {
        background-color: rgb(249, 181, 181);
        position: absolute;
        height: 300px;
        top: 0px;
        left: 0px;
        right: 0px;
      }
      .wrap {
        background-color: rgb(212, 238, 252);
        position: relative;
        width: 500px;
        height: 500px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="content">content</div>
    </div>
  </body>
```

实验证明，确实可以做到 100%

### 2.mainStore 的思想

原来入住和离店时间我们是设置在 search 组件里的，有点不妥，因为整个项目有很多地方都需要时间，这可以单独创建个 store，用来存储公共的数据。
像 token 这些都可以存储在 mainStore 里面。

![1659405897086](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1659405897086.png)

修改代码仔细点。

```js
const useMainStore = defineStore("main", {
  state: () => ({
    token: "",
    startDate,
    endDate,
  }),
  getters: {
    startDateStr() {
      return (formatStr = "MM月DD日") => {
        formatMonthDate(this.startDate, formatStr);
      };
    },
    endDateStr() {
      return (formatStr = "MM月DD日") => {
        formatMonthDate(this.endDate, formatStr);
      };
    },
    diffDays() {
      return getDiffDays(this.startDate, this.endDate);
    },
  },
});
```

再来几个个getters，还能定制日期格式，完美，优雅！



### 3.loding蒙版的实现

我自己是用的opacity实现的：

```css
  background-color: rgb(230, 229, 229);
  color: black;
  opacity: 0.5;
```

这会导致整个loding组件都变成了半透明，不合理

正确做法：

```css
 background-color: rgba(0, 0, 0, 0.2);
```



background竟然有这么多的说法：

`background` 属性被指定多个背景层时，使用逗号分隔每个背景层。

每一层的语法如下：

- 在每一层中，下列的值可以出现 0 次或 1 次：
  - `<attachment>`
  - `<bg-image>`
  - `<position>`
  - `<bg-size>`
  - `<repeat-style>`
  
- `<bg-size>` 只能紧接着 `<position>` 出现，以"/"分割，如： "`center/80%`".

- `<box>` 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 [`background-origin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin) 和 [`background-clip`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip)。如果出现 2 次，第一次的出现设置 [`background-origin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin)，第二次的出现设置 [`background-clip`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip)。

- `<background-color>` 只能被包含在最后一层。

  

### 4.vue-router传参问题

```js
// 字符串路径
router.push('/users/eduardo')

// 带有路径的对象
router.push({ path: '/users/eduardo' })

// 命名的路由，并加上参数，让路由建立 url
router.push({ name: 'user', params: { username: 'eduardo' } })

// 带查询参数，结果是 /register?plan=private
router.push({ path: '/register', query: { plan: 'private' } })

// 带 hash，结果是 /about#team
router.push({ path: '/about', hash: '#team' })
```

**注意**：如果提供了 `path`，`params` 会被忽略，上述例子中的 `query` 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 `name` 或手写完整的带有参数的 `path` ：

```js
const username = 'eduardo'
// 我们可以手动建立 url，但我们必须自己处理编码
router.push(`/user/${username}`) // -> /user/eduardo
// 同样
router.push({ path: `/user/${username}` }) // -> /user/eduardo
// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益
router.push({ name: 'user', params: { username } }) // -> /user/eduardo
// `params` 不能与 `path` 一起使用
router.push({ path: '/user', params: { username } }) // -> /user
```



难怪我说怎么这个params不起作用，用name+params的话，在定义路由时就不用定义属性了：

```js
   {
      name: "detail",
      path: "/detail",
      component: () => import("@/views/detail/Detail.vue"),
    },
```

```js
router.push({
    // path: `/detail/${houseData.houseId}`,
    name: "detail",
    params: {
      id: houseData.houseId,
    },
  });
```



而且用户在地址栏还看不见参数，好用！但是你在定义route时设置了动态路由也就是params参数的话，

```js
path: "/detail/:id",
```

那就必须携带上对应的值：

```js
  router.push({
    // path: `/detail/${houseData.houseId}`,
    name: "detail",
    params: {
      id: houseData.houseId,
      name: "detail",
    },
```

**那么地址栏里就可以看到id对应的值，确看不到name对应的值！**

